---
title: "1409 daily"
author: "Junsong Tang"
date: "5/16/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tseries)
library(xts)
library(zoo)
library(tidyverse)
library(forecast)
library(stlplus)
library(seasonal)
library(L1pack)


```


<!-- ```{r, echo=TRUE} -->
<!-- dailyFrame = function(data, impute=FALSE) { -->
<!--   # number of years -->
<!--   n = length(data[, 1]) -->

<!--   # format unit month & days in calender -->
<!--   month = NULL -->
<!--   day = NULL -->
<!--   for (m in (1:12)) { -->
<!--     if ((m <= 7 && m %% 2 == 1) || (m >= 8 && m %% 2 == 0)) { -->
<!--       month = c(month, rep(m, 31)) -->
<!--       day = c(day, seq(from = 1, to = 31, by = 1)) -->
<!--     } else if (m == 2) { -->
<!--       month = c(month, rep(m, 28)) -->
<!--       day = c(day, seq(from = 1,to = 28,by = 1)) -->
<!--     } else { -->
<!--       month = c(month, rep(m, 30)) -->
<!--       day = c(day, seq(from = 1,to = 30,by = 1)) -->
<!--     } -->
<!--   } -->
<!--   # repeat unit format for n years -->
<!--   months = rep(month, n) -->
<!--   days = rep(day, n) -->


<!--   values = NULL -->
<!--   years = NULL -->
<!--   for (i in (1:n)) { -->
<!--     for (j in (1:365)) { -->
<!--       values = c(values, data[i,j]) -->
<!--       #N/A & imputation if applicable -->
<!--       if (impute) { -->
<!--         ind = (i-1)*365 + j -->
<!--         if (is.na(values[ind])) { -->
<!--           values[ind] = values[ind-365] -->
<!--         } -->
<!--       } -->
<!--       years = c(years, 1980+i-1) -->
<!--     } -->
<!--   } -->

<!--   return(data.frame(years, months, days, values)) -->
<!-- } -->

<!-- ``` -->



#=======================================================================================
# Daily unimputed data
```{r, echo=TRUE}
# data1409 = mget(load("D:/NSERC/project/processedData/1409_dat.RData"))
daily = daily_frame(data1409)
# daily = dailyFrame(data1409$resp_mat)
# daily2 = data.frame(resp = as.vector(t(resp_mat)),
#                     rain = as.vector(t(rain_mat)),
#                     snow = as.vector(t(snow_mat)),
#                     temp = as.vector(t(temp_mat)),
#                     year = rep(1980:(1980+nrow(resp_mat)-1), each=ncol(resp_mat)),
#                     day = 1:ncol(resp_mat))

# identifying the range of NA
daily[is.na(daily$resp),]

# subset of log-daily from 1980.1 - 1994.12(15 years)
daily_ts = ts(log(daily$resp), start=c(1980,1), frequency = 365)
plot(daily_ts)
acf(daily_ts, lag.max = 365*5, main = "acf of daily response", na.action = na.pass)
pacf(daily_ts, lag.max = 365*5, main = "pacf of daily respoonse", na.action = na.pass)

# train set 12 years, test set 3 years
daily_train = window(daily_ts, start=c(1980,1), end=c(1991,365))
daily_test = window(daily_ts, start=c(1992,1), end=c(1994,365))


plot(daily_train, col="red", xlim = c(1980, 1995), main="Train & Test")
lines(daily_test, col="blue")
```




#========================================================================================
# Loess decomposition
```{r echo=TRUE}
# loess = stlplus(daily_train, s.window = "periodic", s.degree = 2)
na.new = function(x) {ts(na.exclude(x), start = c(1980,1), frequency = 365)}
loess = stl(daily_ts, s.window = "periodic", na.action = na.new)
plot(loess)
# check residuals
# daily_ts has length 13870; while residual has 13398, probably due to NAs in raw ts.
error = loess$time.series[,"remainder"]
qqnorm(error)
qqline(error)
acf(error, lag.max= 365*5, main="acf of residual")
pacf(error, lag.max = 365*3, main="pacf of residual")
pacf(error, main="pacf of residual")


model = arima(error, order = c(5,0,0), include.mean = TRUE)
acf(model$residuals)
pacf(model$residuals, lag.max = 365)
tsdiag(model)

# #de-seasonalize
# daily.train.ds = daily_train - loess$time.series[,"seasonal"]
# plot(daily.train.ds, main ="de-seasonalized")
# acf(daily.train.ds, lag.max = 365*5, main = "acf ds")
# pacf(daily.train.ds, lag.max = 365*5, main = "pacf ds")
# 
# # re-center
# daily.mu = mean(daily.train.ds)
# daily.train.rc = daily.train.ds - daily.mu
# plot(daily.train.rc, main ="de-seasonalized & re-centered ts")
# acf(daily.train.rc, lag.max = 365*5, main = "acf ds + rc")
# pacf(daily.train.rc, lag.max = 365*5, main = "pacf ds + rc")

```











#=======================================================================================
Seasonality

1st version ($c = E[(A^TA)^{-1}A^TY] = (A^TA)^{-1}A^T E(Y)$)

2nd version
# (1) x = (-2,-1,0,1,2,-2,-1,0,1,2,...); y = ($,$,$,$,$,&,&,&,&,&,...) horizontal then vertical(this method is not convenient to remove outliers in each cluster at same day)

# (2) x = (-2,-2,-2,...,-1,-1,-1,...,0,0,0,...,1,1,1,...,2,2,2,...); 
# y = ($,&,#,...,$,&,#,...,$,&,#,...,$,&,#,...,$,&,#,...,), vertical then horizontal


# helper: re-arrange the raw time series into same day equivalent classes
```{r, echo=TRUE}
# trim: boolean - whether to trim out the outliers of cluster(matrix row)
# same_day_cluster = function(ts, trim=FALSE) {
#   k = floor(tsp(ts)[2]-tsp(ts)[1])+1
#   freq = as.integer(tsp(ts)[3])
# 
#   M = list()
#   for (i in (1:freq)) {
#     indices = seq(from=i, to=i+(k-1)*freq, by=freq)
#     row = ts[indices]
#     # whether to remove outliers or not
#     if (trim) {
#       # set quantile & subset
#       range = quantile(row, prob = c(0.25, 0.75), na.rm = TRUE)
#       lb = as.numeric(range[1])
#       ub = as.numeric(range[2])
#       row = row[lb<=row&row<=ub]
#     }
#     M[[i]] = row
#   }
#   return (M)
# }


# trim: percent of lower tail
same_day_cluster = function(ts, trim=0) {
  k = floor(tsp(ts)[2]-tsp(ts)[1])+1
  freq = as.integer(tsp(ts)[3])

  M = list()
  for (i in (1:freq)) {
    indices = seq(from=i, to=i+(k-1)*freq, by=freq)
    row = ts[indices]
    # whether to remove outliers or not
    if (trim != 0) {
      # set quantile & subset
      range = quantile(row, prob = c(trim, 1-trim), na.rm = TRUE)
      lb = as.numeric(range[1])
      ub = as.numeric(range[2])
      row = row[lb<=row&row<=ub]
    }
    M[[i]] = row
  }
  return (M)
}




```


#run time test
```{r, echo=TRUE}
start_time = Sys.time()
m = same_day_cluster(daily_ts, trim=0)
end_time = Sys.time()
end_time - start_time


```

```{r, echo=TRUE}
# trim: real number in [0,1], representing percentage of the lower tail
seasonality = function(ts, window, degree, trim) {
  # number of years
  k = floor(tsp(ts)[2]-tsp(ts)[1])+1
  freq = as.integer(tsp(ts)[3])
  
  equi_class = same_day_cluster(ts, trim=trim)
  n = length(equi_class[[1]])
  
  seasonality = NULL
  for (i in (1:freq)) {
    # [-w+i,..i,...w+i]
    interval = seq(from=-window+i, to=window+i, by=1)
    y = NULL
    x = NULL
    for (w in interval) {
      if (w < 1) {
        cluster = (equi_class[[w+freq]])[-n]
      }
      else if (w > freq) {
        cluster = (equi_class[[w-freq]])[-1]
      }
      else {
        cluster = equi_class[[w]]
      }
      
      cluster = cluster[!is.na(cluster)]
      
      y = c(y, cluster)
      x = c(x, rep(w-i, length(cluster)))
    }
    
    if (degree == 0) {
      model = lm(y ~ 1)
      yhat = as.numeric(model$fitted.values[which(x==0)][1])
    }
    if (degree == 1) {
      model = lm(y ~ x)
      yhat = as.numeric(model$fitted.values[which(x==0)][1])
    }
    if (degree == 2) {
      model = lm(y ~ x+I(x^2))
      yhat = as.numeric(model$fitted.values[which(x==0)][1])
    }
    if (degree == 3) {
      model = lm(y ~ x+I(x^2)+I(x^3))
      yhat = as.numeric(model$fitted.values[which(x==0)][1])
    }
    
    slots = seq(from=i, to=i+(k-1)*freq, by=freq)
    seasonality[slots] = yhat
  }
  
  return (seasonality)
}



```




<!-- (5) Least absolute deviations(LAD) regression -->
<!-- ```{r, echo=TRUE} -->
<!-- seasonality5 = function(ts, window, degree) { -->
<!--   # number of years -->
<!--   k = floor(tsp(ts)[2]-tsp(ts)[1])+1 -->
<!--   freq = as.integer(tsp(ts)[3]) -->

<!--   equi_class = same_day_cluster(ts, trim=FALSE) -->
<!--   n = length(equi_class[[1]]) -->

<!--   seasonality = NULL -->
<!--   for (i in (1:freq)) { -->
<!--     # [-w+i,..i,...w+i] -->
<!--     interval = seq(from=-window+i, to=window+i, by=1) -->
<!--     y = NULL -->
<!--     x = NULL -->
<!--     for (w in interval) { -->
<!--       if (w < 1) { -->
<!--         cluster = (equi_class[[w+freq]])[-n] -->
<!--       } -->
<!--       else if (w > freq) { -->
<!--         cluster = (equi_class[[w-freq]])[-1] -->
<!--       } -->
<!--       else { -->
<!--         cluster = equi_class[[w]] -->
<!--       } -->

<!--       cluster = cluster[!is.na(cluster)] -->

<!--       y = c(y, cluster) -->
<!--       x = c(x, rep(w-i, length(cluster))) -->
<!--     } -->

<!--     if (degree == 0) { -->
<!--       yhat = median(y) -->
<!--     } -->
<!--     if (degree == 1) { -->
<!--       model = lad(y ~ x) -->
<!--       yhat = as.numeric(model$fitted.values[which(x==0)][1]) -->
<!--     } -->
<!--     if (degree == 2) { -->
<!--       model = lad(y ~ x+I(x^2)) -->
<!--       yhat = as.numeric(model$fitted.values[which(x==0)][1]) -->
<!--     } -->
<!--     if (degree == 3) { -->
<!--       model = lad(y ~ x+I(x^2)+I(x^3)) -->
<!--       yhat = as.numeric(model$fitted.values[which(x==0)][1]) -->
<!--     } -->

<!--     slots = seq(from=i, to=i+(k-1)*freq, by=freq) -->
<!--     seasonality[slots] = yhat -->
<!--   } -->

<!--   return (seasonality) -->
<!-- } -->


<!-- ``` -->


# run time test using 2nd version

# runtime for seasonality
```{r, echo=TRUE}
start_time = Sys.time()
# keep the outliers
s1 = seasonality(daily_ts, window = 51, degree = 2, trim=0)
end_time = Sys.time()
end_time - start_time

```

```{r, echo=TRUE}
start_time = Sys.time()
# remove the outliers
s2 = seasonality(daily_ts, window = 51, degree = 2, trim=0.25)
end_time = Sys.time()
end_time - start_time

```






# plot seasonality
```{r, echo=TRUE}
plot(s1, type ="l", xlim = c(0,1000), col = "black", main="s1&s2: with/without outliers")
lines(s2, type = "l", xlim = c(0,1000), col = "red")


```








# Cross validation(5 fold)
# 38 => 8 + 8 + 8 + 8 + 6
```{r, echo=TRUE}
bestSeason = function(ts, window.max = 10, trim_per.max = 0.25) {
  start_year = tsp(ts)[1]
  end_year = tsp(ts)[2]
  k = floor(tsp(ts)[2]-tsp(ts)[1])+1 #k = 38 years
  t = ceiling(k/5) #t = 8 years/unit
  freq = as.integer(tsp(ts)[3])
  minSMSR = Inf
  best_window = 0
  best_degree = 0
  best_trim = 0
  for (w in (0:window.max)) {
    for (d in (0:3)) {
      for (p in (0:(trim_per.max/0.05))) {
        # sum of mean squared error over CVs
        SMSR = 0
        # run 5 times CV
        for (i in (1:5)) {
          test_index = seq(from=1+(i-1)*t*freq, to=min(i*t*freq, k*freq), by=1)
          test = ts[test_index]
          test = ts(test, start=c(start_year+(i-1)*t, 1), frequency = freq)
          
          train = ts[-test_index]
          train = ts(train, start=c(start_year, 1), frequency = freq)
          seasonality = seasonality(train, w, d, trim=p*0.05)
          
          
          pred = seasonality[1:length(test)]
          residual = (test - pred)
          SMSR = SMSR + mean(residual^2, na.rm = TRUE)
        }
        
        
        
        # for (year in (1:k)) {
        #   test_index = seq(from=1+(year-1)*freq, to=year*freq, by=1)
        #   test = ts[test_index]
        #   # test must be converted into ts object!!!
        #   test = ts(test, start=c(start_year+(year-1), 1), frequency = freq)
        #   train = ts[-test_index]
        #   # train must be converted into ts object!!!
        #   train = ts(train, start=c(start_year, 1), frequency = freq)
        #   seasonality = seasonality4(train, w, d)
        #   pred = seasonality[1:freq]
        #   residual = (test - pred)
        #   SMSR = SMSR + mean(residual^2, na.rm = TRUE)
        # }
        
        if (SMSR < minSMSR) {
          best_window = w
          best_degree = d
          best_trim = p
          minSMSR = SMSR
        }
      }
    }
  }
  
  return (data.frame(best_window, best_degree, best_trim))
}

```


```{r, echo=TRUE}
# long runtime!!!
start_time = Sys.time()
bestSeason(daily_ts, window.max = 11, trim_per.max = 0.25)
end_time = Sys.time()
end_time - start_time
```







```{r, echo=TRUE}
start_time = Sys.time()
bestSeason(daily_ts, window.max = 10, trim_per.max = 0)
end_time = Sys.time()
end_time - start_time

```



```{r, echo=TRUE}
best_seasonal = seasonality(daily_ts, window=11, degree=0, trim=0.05)
plot(ts(best_seasonal, start=c(1980,1), frequency=365), xlim=c(1980,2000),ylim=c(-5,5), type="l", main="best seasonality(11, 0, 5%) & raw ts")
lines(daily_ts, col = "green")

# remain = daily_ts - best_seasonal
# obj = stl(remain, s.window = "periodic", na.action = na.pass)
# plot(obj)

```




<!-- # package: parallel -->
<!-- ```{r, echo=TRUE} -->
<!-- library(parallel) -->
<!-- library(pbapply) -->

<!-- l <- list(a = c(1,2), b = c(1,2,3))                                 # example list -->
<!-- f <- function(x){return(length(x))}                           # example function -->

<!-- n_cores <- detectCores()                                          # determine number of cores -->
<!-- cl <- makeCluster(n_cores - 1)                                 # use all (except for 1) cores and start cluster -->

<!-- pblapply(l, f, cl = cl)                                                    # use pblapply instead of lapply -->

<!-- stopCluster(cl)                                                            # stop cluster -->



<!-- ``` -->





















































#========================================================================================
# Model Fitting
<!-- # Classical Decomposition by moving average -->
<!-- ```{r, echo=TRUE} -->
<!-- component = decompose(daily_train, type = "additive", filter = c()) -->
<!-- plot(component) -->
<!-- acf(component$random, na.action = na.pass, lag.max = 365*10) -->
<!-- pacf(component$random, na.action = na.pass, lag.max = 365*5) -->
<!-- pacf(component$random, na.action = na.pass) -->

<!-- ``` -->

# ARIMA(5,0,0) model fitting
```{r, echo=TRUE}
arima_model = arima(error, order = c(5,0,0), include.mean = TRUE)
plot(arima_model$residuals)
acf(arima_model$residuals)
pacf(arima_model$residuals, lag.max = 365)
tsdiag(arima_model)
qqnorm(arima_model$residuals)
qqline(arima_model$residuals)

```






# Box-Jenkins Forecast Method Function
```{r, echo=TRUE}
box_jenkins = function(model, ahead) {
  n = length(model$coef)
  mu = model$coef[n]
  preds = NULL
  order = n - 1
  # the list of previous values till today
  queue = window(error, start=c(1991,365-order+1), end=c(1991,365))
  while (ahead != 0) {
    pred = 0
    for (i in (1:order)) {
      pred = pred + as.numeric(queue[order-i+1]) * as.numeric(model$coef[i])
    }
    preds = c(preds, pred)
    queue = c(queue[-1], pred)
    ahead = ahead - 1
  }
  return (ts(preds, start=c(1992,1), frequency = 365))
  
}


```



# ARIMA(5,0,0) model forecast
```{r, echo=TRUE}
lag = 15
future_days = window(daily_test, start=c(1992,1), end=c(1992,lag))


pred1 = predict(arima_model, n.ahead = lag)
predict_values = pred1$pred + loess$time.series[, "trend"][1:lag] + loess$time.series[,"seasonal"][1:lag]
plot(predict_values, col="black", ylim = c(-1.5,-0.5), main="prediction")
lines(future_days, col="red")

#box-jenkins method prediction
pred2 = box_jenkins(arima_model, ahead = lag)
predict_values2 = pred2 + loess$time.series[, "trend"][1:lag] + loess$time.series[,"seasonal"][1:lag]
plot(predict_values2, col="black", ylim = c(-1.5,-0.5), main="prediction")
lines(future_days, col="red")


plot(pred1$pred, col="black", main="prediction")
lines(pred2, col="red")


```









