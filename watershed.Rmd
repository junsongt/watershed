---
title: "watershed"
author: "Junsong Tang"
date: "6/6/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(terra)
library(leaflet)
library(knitr)
library(tseries)
library(xts)
library(zoo)
library(forecast)
library(sp)
library(sf)
library(rgdal)
library(raster)
```




#========================================================================================# Global variables
```{r, echo=TRUE}
path = "D:/NSERC/project/processedData/"
fileNames = list.files(path)

# load shapes
shapes = vect("D:/NSERC/project/WaterShedDataExample/ToyData/Shape_Files/CANUS_Watershed_Boundaries.shp")

# coordinates
gridInfo = read.csv("D:/NSERC/project/WaterShedDataExample/GridInfo.csv", sep = ";")


# given file path, return list of Rdata(cube)
readData = function(path) {
  fileNames = list.files(path)
  filesList = list()
  for (i in (1:length(fileNames))) {
    suffix = fileNames[i]
    datafile = mget(load(paste0(path, suffix)))
    # mget returns a list of single-element list:[[*], [*], ...], use index form datafile[[i]]
    filesList[[i]] = datafile
  }
  return(filesList)
}



# # alldata is a list of Rdata(cube)
# alldata = readData("D:/NSERC/project/processedData/")

```








#========================================================================================
# Helpers


# ts format
```{r, echo=TRUE}
# mtx: data matrix
# returns ts object from start_year to end_year with freq
matrix_to_ts = function(mtx, freq = 365, start_year, end_year) {
  y = as.vector(t(mtx))
  return (ts(y, start = c(start_year, 1), end = c(end_year, 365), frequency = freq))
}

# category is string: the matrix name in Rdata file, i.e. "resp_mat"
# returns ts object of given category
cube_to_ts = function(Rdata, category) {
  if (category != "rain_mat" ||
      category != "snow_mat" ||
      category != "temp_mat" ||
      category != "resp_mat" ||
      category != "yrs") {
    print("Error!")
    return ()
  }
  mtx = Rdata$category
  start = Rdata$yrs[1]
  end = Rdata$yrs[length(Rdata$yrs)]
  return (matrix_to_ts(mtx, start, end))
}



# window is vector of string format dates: window = c("1980-01-01", "2000-01-01")
SUBSET = function(mtx, window) {
  start_year = substr(window[1], start=1, stop=4)
  end_year = substr(window[2], start=1, stop=4)
  ts = matrix_to_ts(mtx, start_year, end_year)
  return (window(ts, start=c(start_year, 1), end=c(end_year, 365)))
}


```


# Arithmetic
```{r, echo=TRUE}
# sum of some values within a matrix
SUM = function(m, window = c()) {
  years = m$yrs
  lb = as.Date(paste0(years[1], "-01-01"))
  ub = as.Date(paste0(years[length(years)], "12-31"))
  start = window[1]
  end = window[2]
  if (start < lb || end > ub) {
    print("window input error!")
    return ()
  }
  
  sum = 0
  for (i in (nrow(m))) {
    sum = sum + sum(m[i,], na.rm = TRUE)
  }
  return (sum)
}

# mean of some values within a matrix
MEAN = function(m) {
  return (SUM(m) / length(m))
}

# window sum
windowSUM = function(m, window) {
  return()
}

# window mean
windowMEAN = function(m, window) {
  return (windowSUM(m, window) / length())
}

```


# Format
```{r, echo=TRUE}
# month-format
month_format = function() {
  month = NULL
  for (m in (1:12)) {
    if ((m <= 7 && m %% 2 == 1) || (m >= 8 && m %% 2 == 0)) {
      month = c(month, rep(m, 31))
    } else if (m == 2) {
      month = c(month, rep(m, 28))
    } else {
      month = c(month, rep(m, 30))
    }
  }
  return (month)
}


# day-format
day_format = function() {
  day = NULL
  for (m in (1:12)) {
    if ((m <= 7 && m %% 2 == 1) || (m >= 8 && m %% 2 == 0)) {
      day = c(day, seq(from = 1, to = 31, by = 1))
    } else if (m == 2) {
      day = c(day, seq(from = 1,to = 28,by = 1))
    } else {
      day = c(day, seq(from = 1,to = 30,by = 1))
    }
  }
  return (day)
}

# given a Rdata file, return a complete data frame(with covariates & response)
dailyFrame = function(Rdata, impute=FALSE) {
  # number of years
  n = length(Rdata[[1]][, 1])
  
  # format unit month & days in calender
  month = month_format()
  day = day_format()
  # repeat unit format for n years
  months = rep(month, n)
  days = rep(day, n)
  # format years from 1980 to 
  years = rep(1980:(1980+n-1), each=365)
  
  frame = data.frame(years, months, days)
  for (k in (1:(length(Rdata)-1))) {
    # data one of matrices in Rdata(cube) file
    data = Rdata[[k]]
    values = NULL
    for (i in (1:n)) {
      for (j in (1:length(data[1,]))) {
        values = c(values, data[i,j])
        #N/A & imputation if applicable
        if (impute) {
          ind = (i-1)*365 + j
          if (is.na(values[ind])) {
            values[ind] = values[ind-365]
          }
        }
      }
    }
    
    if (dim(frame)[1] == length(values)) {
      frame = data.frame(frame, values)
      names(frame)[k+3] = names(Rdata)[k]
    }
    # else, we could pad the shorter vector: length(values) = dim(frame)[1]
    # frame = data.frame(frame, values)
    # names(frame)[k+3] = names(Rdata)[k]
  }
  return (frame)
}


# results <- sapply(files, function(x) mget(load(paste0("D:/NSERC/project/processedData", x))), simplify = TRUE)

```


#========================================================================================
# Functionalities

# plot some shapes
```{r, echo=TRUE}
# given a list/vector of indices, plot the shp of watershed
max_shape_num = 5
plot_shape = function(index) {
  if (length(index) > max_shape_num) {
    print(paste("Error: max number of watersheds is", max_shape_num))
    return()
  }
  plot(shapes[index])
}

```


#tests
```{r, echo=TRUE}
plot_shape(c(1:6))
plot_shape(c(1:5))
plot_shape(c(11,79,101,200,5))

```

# plot watersheds's boundaries
```{r, echo=TRUE}
# shapes: a set of shape files, e.g., shp_dat[1:3];
# map: boolean - TRUE puts boundaries on a map;
plot_boundaries = function(shapes, map) {
  if (map) {
    leaflet(sf::st_as_sf(shapes)) %>% addTiles() %>% addPolygons(fillOpacity=0.1)
    # %>% addMarkers(lng=???, lat=???, popup="watershed No.")
    
  }
  else {
    plot(shapes)
  }
}

```

#tests
```{r, echo=TRUE}
plot_boundaries(shapes[1:4], FALSE)
plot_boundaries(shapes[1:4], TRUE)
plot_boundaries(shapes[c(1, 11, 101, 31, 77)], TRUE)
```




# inside region?
```{r, echo=TRUE}
# shape: a single shape file
# long_min, long_max, lat_min, lat_max: lower and upper bounds on longitude and latitude;
# Returns a boolean whether the shape is wholly inside the region or just partially inside;;
inside_region = function(shape, long_min, long_max, lat_min, lat_max) {
  x_min = xmin(shape)
  x_max = xmax(shape)
  y_min = ymin(shape)
  y_max = ymax(shape)
  return (long_min <= x_min && x_min <= long_max && lat_min <= y_min && y_max <= lat_max)
  # longs = geom(shape)[,3]
  # lats = geom(shape)[,4]
  # strict = TRUE
  # i = 1
  # while (strict && i <= length(longs)) {
  #   if (!(long_min <= longs[i] && longs[i] <= long_max && lat_min <= lats[i] && lats[i] <= lat_max)) {
  #     strict = FALSE
  #   }
  #   i = i + 1
  # }
  # return (strict)
}


```


#tests
```{r, echo=TRUE}
plot_shape(c(1))
start_time = Sys.time()
inside_region(shapes[1], -132, -125, 57, 59.5)
inside_region(shapes[1], -133, -126, 57, 59.5)
end_time = Sys.time()
end_time - start_time

```





# region
```{r, echo=TRUE}
# shapes: a list of shape files
# Returns the index of the shape containing the longitude and latitude
region = function(shapes, long, lat) {
  indices = NULL
  for (i in (1:length(shapes))) {
    longs = geom(shapes[i])[,3]
    lats = geom(shapes[i])[,4]
    if (point.in.polygon(point.x = long, 
                         point.y = lat,
                         pol.x = longs,
                         pol.y = lats)) {
      indices = c(indices, i)
    }
  }
  return (indices)
}

```


#tests
```{r, echo=TRUE}
plot_boundaries(shapes[1:4], FALSE)
region(shapes[1:4], long = -125, lat = 55.1)


```


# region(return grid code/station ID)
```{r, echo=TRUE}
# region = function(shapes, long, lat) {
#   IDs = NULL
#   for (i in (1:length(shapes))) {
#     longs = geom(shapes[i])[,3]
#     lats = geom(shapes[i])[,4]
#     if (point.in.polygon(point.x = long, 
#                          point.y = lat,
#                          pol.x = longs,
#                          pol.y = lats)) {
#       IDs = c(IDs, shapes[i]$Station_ID)
#     }
#   }
#   return (IDs)
# }

```










# snow fraction
```{r, echo=TRUE}
# A multivariate time series including univariate time series named "rain" and "snow"
# Returns the snow fraction, i.e., total snow / (total rain + total snow).
# Any time with missing rain or snow or both is ignored.


# mts is usually a data frame with col:
# Time snow_mat rain_mat
snow_fraction = function(mts) {
  snow = mts$snow_mat
  rain = mts$rain_mat
  snow_sum = 0
  rain_sum = 0
  # assume that snow & rain matrices have same dimensions
  for (r in (1:nrow(snow))) {
    for (c in (1:length(snow[1,]))) {
      # NA issue
      if (!is.na(snow[r,c]) && !is.na(rain[r,c])) {
        snow_sum = snow_sum + snow[r,c]
        rain_sum = rain_sum + rain[r,c]
      }
      
    }
  }
  snow_ratio = snow_sum / (snow_sum + rain_sum)
  return (snow_ratio)
}


```

# rain fraction
```{r, echo=TRUE}
rain_fraction = function(mts) {
  snow = mts$snow_mat
  rain = mts$rain_mat
  snow_sum = 0
  rain_sum = 0
  # assume that snow & rain matrices have same dimensions
  for (r in (1:nrow(snow))) {
    for (c in (1:length(snow[1,]))) {
      # NA issue
      if (!is.na(snow[r,c]) && !is.na(rain[r,c])) {
        snow_sum = snow_sum + snow[r,c]
        rain_sum = rain_sum + rain[r,c]
      }
    }
  }
  rain_ratio = rain_sum / (snow_sum + rain_sum)
  return (rain_ratio)
}

```

# precipitation ratio
```{r, echo=TRUE}
# given a list/vector of indices, compute the precipitation ratio of given watershed index in data frame form
# Any time with missing rain or snow or both is ignored.
precip_ratio = function(index) {
  snow_ratios = NULL
  rain_ratios = NULL
  watershed = NULL
  for (i in index) {
    suffix = fileNames[i]
    datafile = mget(load(paste0(path, suffix)))
    
    # snow_ratio = snow_fraction(datafile)
    # rain_ratio = rain_fraction(datafile)
    
    snow = datafile$snow_mat
    rain = datafile$rain_mat
    
    snow_sum = 0
    rain_sum = 0
    # assume that snow & rain matrices have same dimensions
    for (r in (1:nrow(snow))) {
      for (c in (1:length(snow[1,]))) {
        # NA issue
        if (!is.na(snow[r,c]) && !is.na(rain[r,c])) {
          snow_sum = snow_sum + snow[r,c]
          rain_sum = rain_sum + rain[r,c]
        }
        
      }
    }

    snow_ratio = snow_sum / (snow_sum + rain_sum)
    rain_ratio = rain_sum / (snow_sum + rain_sum)
    snow_ratios = c(snow_ratios, snow_ratio)
    rain_ratios = c(rain_ratios, rain_ratio)
    watershed = c(watershed, suffix)
  }
  return (data.frame(watershed, snow_ratios, rain_ratios))
}

```



