---
title: "watershed"
author: "Junsong Tang"
date: "6/6/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(terra)
library(leaflet)
library(knitr)
library(tseries)
library(xts)
library(zoo)
library(forecast)
library(sp)
library(sf)
library(rgdal)
library(raster)
library(maptiles)
library(shiny)
library(ggplot2)
```



#========================================================================================# Global variables

<!-- ```{r, echo=TRUE} -->
<!-- PATH = "D:/NSERC/project/processedData/" -->
<!-- FILENAMES = list.files(PATH) -->

<!-- # load shapes -->
<!-- SHAPES = vect("D:/NSERC/project/WaterShedDataExample/ToyData/Shape_Files/CANUS_Watershed_Boundaries.shp") -->
<!-- # shape_attr = st_read("D:/NSERC/project/WaterShedDataExample/ToyData/Shape_Files/CANUS_Watershed_Boundaries.shp") -->

<!-- ``` -->

```{r, echo=TRUE}
GRIDCODES = GRIDINFO$gridcode
SHAPES = vect(SHAPES)
```



```{R, echo=TRUE}
# given file path, return list of Rdata(cube)
# loadAllData = function(path) {
#   fileNames = list.files(path)
#   filesList = list()
#   for (i in (1:length(fileNames))) {
#     suffix = fileNames[i]
#     data = mget(load(paste0(path, suffix)))
#     # mget returns a list of single-element list:[[*], [*], ...], use index form datafile[[i]]
#     filesList[[i]] = data
#   }
#   return(filesList)
# }


loadAllData = function(path) {
  fileNames = list.files(path)
  filesList = lapply(c(1:max(GRIDCODES)), FUN=function(x){NULL})
  for (fn in fileNames) {
    index = as.numeric(substr(fn, start=1, stop=nchar(fn)-10))
    data = mget(load(paste0(path, fn)))
    # mget returns a list of single-element list:[[*], [*], ...], use index form datafile[[i]]
    filesList[[index]] = data
  }
  return(filesList)
}

```



```{r, echo=TRUE}
DATA = loadAllData("D:/NSERC/project/processedData/")
save(DATA, file="DATA.RData")

```

```{r, echo=TRUE}
SHAPES = wrap(SHAPES)
save(SHAPES, file="SHAPES.RData")

```


```{r, echo=TRUE}
save(GRIDINFO, file="GRIDINFO.RData")

```




#========================================================================================
# Helpers(under construction)

# ts format
```{r, echo=TRUE}
# univariate time series
# data: matrix or vector/list form containing all daily data of single category(snow,rain)
# returns ts object from start_year to end_year with freq
uts = function(data, freq = 365, start_year, end_year) {
  if (is.vector(data) || is.list(data)) {
    return (ts(data, start = c(start_year, 1), end = c(end_year, 365), frequency = freq))
  }
  if (is.matrix(data)) {
    # as.vector goes along the column(vertically) of a matrix
    y = as.vector(t(data))
    return (ts(y, start = c(start_year, 1), end = c(end_year, 365), frequency = freq))
  }
  
  
}

# # category is string: the matrix name in Rdata file, i.e. "resp_mat", "rain_mat"
# # returns ts object of given category
# cube_to_ts = function(Rdata, category) {
#   mtx = Rdata[[which(names(Rdata) == category)]]
#   start = Rdata$yrs[1]
#   end = Rdata$yrs[length(Rdata$yrs)]
#   return (matrix_to_ts(mtx, start_year=start, end_year=end))
# }


# multivariate time series
# input: strict list form of data, containing multiple items, and the last item should be a linear container of years span.
# return a multivariate ts in data frame
mts = function(data) {
  df = data.frame()
  for (i in (1:(length(data)-1))) {
    item = data[[i]]
    start = data$yrs[1]
    end = data$yrs[length(data$yrs)]
    ts = uts(item, start_year=start, end_year=end)
    if (dim(df)[1] == 0) {
      df = data.frame(ts)
    } # if current ts has same length as previous ones
    else if (dim(df)[1] == length(ts)) {
      df = cbind(df, ts)
    } # if current ts differs in length from previous ones, then trim(longer)/pad(shorter)
    else {
      length(ts) = dim(df)[1]
      df = cbind(df, ts)
    }
    names(df)[i] = substr(names(data)[i],start=1,stop=4)
  }
  return (df)
  
}

# remark: mts is data frame, also list object, to access one ts element, use list index


```

#test
```{r, echo=TRUE}
start_time = Sys.time()
mts1409 = mts(DATA[[1409]])
end_time = Sys.time()
end_time - start_time

```





=========================================================================================
<!-- # Watershed object -->

<!-- attributes: -->
<!-- # mts(snow, rain, temp, resp) -->
<!-- # gridcode -->
<!-- # index: shape object index -->
<!-- # name: name of the watershed -->


<!-- method: -->
<!-- # get_fraction() -->
<!-- # render_plot -->
<!-- # ... -->


<!-- constructor input: -->
<!-- #data: has to be in list form(data frame containing covariates), because it has to contain snow, rain, temp, resp -->
<!-- # (i.e. RData, data frame), also could be null -->
<!-- # gridcode has to be integer, non-null -->
<!-- # index has to be integer, non-null -->
<!-- ```{r, echo=TRUE} -->
<!-- Watershed = function(data, gridcode, index) { -->
<!--   # check shape & gridcode -->
<!--   # (1) all inputs are correct -->
<!--   shape = SHAPES[index] -->
<!--   if (shape$gridcode == gridcode && is.numeric(gridcode) && gridcode %in% GRIDCODES){ -->
<!--     obj = NULL -->
<!--     if (is.null(data)) { -->
<!--       mts = NULL -->
<!--     } -->
<!--     else if ((is.vector(data) || is.list(data) || is.data.frame(data))) { -->
<!--       mts = mts(data) -->
<!--     } -->
<!--     else { -->
<!--       stop("data is not of correct type!") -->
<!--       return () -->
<!--     } -->
<!--     obj$mts = mts -->
<!--     obj$gridcode = gridcode -->
<!--     obj$index = index -->
<!--     obj$name = shape$Station_NA -->
<!--     class(obj) = "Watershed" -->
<!--     return (obj) -->

<!--   } -->
<!--   else if (shape$gridcode != gridcode){ -->
<!--     stop("gridcode mismatch shape!") -->
<!--     return () -->
<!--   }  -->
<!--   else if (!is.numeric(gridcode)) { -->
<!--     stop("gridcode is not of correct type!") -->
<!--     return () -->
<!--   } -->
<!--   else { -->
<!--     stop("such grid code does not exist!") -->
<!--     return () -->
<!--   } -->

<!-- } -->


<!-- ``` -->



# Watershed object

attributes:
# gridcode(reference index to data file)
# index: shape object index
# name: name of the watershed


method:
# get_fraction()
# render_plot
# ...


constructor input:
#data: has to be in list form(data frame containing covariates), because it has to contain snow, rain, temp, resp
# (i.e. RData, data frame), also could be null
# gridcode has to be integer, non-null
# index has to be integer, non-null
```{r, echo=TRUE}
Watershed = function(gridcode) {
  # check shape & gridcode
  # (1) all inputs are correct
  index = which(GRIDINFO$gridcode == gridcode)
  if (is.numeric(gridcode) && gridcode %in% GRIDCODES){
    obj = NULL

    obj$gridcode = gridcode
    obj$index = index
    obj$name = GRIDINFO$Station_NA[index]
    class(obj) = "Watershed"
    return (obj)
    
  }
  else if (!is.numeric(gridcode)) {
    stop("gridcode is not of correct type!")
    return ()
  }
  else {
    stop("such grid code does not exist!")
    return ()
  }
  
}


```





```{r, echo=TRUE}
start_time = Sys.time()
ws1409 = Watershed(1409)
end_time = Sys.time()
end_time-start_time

```



```{r, echo=TRUE}
# TODO
# gridcodes: vector of gridcode, i.e.c(1003, 1013, 1409), c(1,10,1001,1409)
# find_watersheds = function() {}
# search by indices: another option
# load.watersheds = function(gridcodes) {
#   watersheds = list()
#   for (i in (1:length(gridcodes))) {
#     gc = gridcodes[i]
#     filename = paste0(gc, "_dat.RData")
#     if (!(filename %in% FILENAMES)) {
#       data = NULL
#     } else {
#       data = mget(load(paste0(PATH, filename)))
#     }
#     index = which(SHAPES$gridcode == gc)
#     ws = Watershed(data, gc, index)
#     watersheds[[i]] = ws
#   }
#   return (watersheds)
#   
# }

# load.watersheds = function(gridcodes) {
#   watersheds = list()
#   for (i in (1:length(gridcodes))) {
#     gc = gridcodes[i]
#     data = DATA[[gc]]
#     index = which(SHAPES$gridcode == gc)
#     ws = Watershed(data, gc, index)
#     watersheds[[i]] = ws
#   }
#   return (watersheds)
#   
# }

load.watersheds = function(gridcodes) {
  watersheds = list()
  for (i in (1:length(gridcodes))) {
    ws = Watershed(gridcodes[i])
    watersheds[[i]] = ws
  }
  return (watersheds)
  
}

```



```{r, echo=TRUE}
start_time = Sys.time()
objs = load.watersheds(c(1:500))
end_time = Sys.time()
end_time-start_time

```






=========================================================================================
# Arithmetic

```{r, echo=TRUE}
snow.fraction.by.gc = function(gridcode) {
  data = DATA[[gridcode]]
  if (is.null(data)) {
    return (NA)
  }
  else {
    mts = mts(data)
    snow = mts$snow
    rain = mts$rain
    snow_sum = 0
    rain_sum = 0
    for (i in (1:length(snow))) {
      s = snow[i]
      r = rain[i]
      # both snow and rain have to be non NA!
      if (!is.na(s) && !is.na(r)) {
        snow_sum = snow_sum + s
        rain_sum = rain_sum + r
      }
    }
    snow_ratio = snow_sum / (snow_sum + rain_sum)
    return (snow_ratio)
  }
}

rain.fraction.by.gc = function(gridcode) {
  return (1 - snow.fraction.by.gc(gridcode))
}

```


```{r, echo=TRUE}
get.fraction.by.gc = function(gridcodes) {
  snow_fraction = NULL
  rain_fraction = NULL
  gridcode = NULL
  for (gc in gridcodes) {
    snow_fraction = c(snow_fraction, snow.fraction.by.gc(gc))
    rain_fraction = c(rain_fraction, rain.fraction.by.gc(gc))
  }
  return (data.frame(gridcodes, snow_fraction, rain_fraction))
  
}


```





```{r, echo=TRUE}
# snow fraction
# input: Watershed object
# return: snow_fraction(double)
# snow.fraction = function(ws) {
#   if (is.null(ws$mts)) {
#     return (NA)
#   }
#   else {
#     snow = ws$mts$snow
#     rain = ws$mts$rain
#     snow_sum = 0
#     rain_sum = 0
#     for (i in (1:length(snow))) {
#       s = snow[i]
#       r = rain[i]
#       # both snow and rain have to be non NA!
#       if (!is.na(s) && !is.na(r)) {
#         snow_sum = snow_sum + s
#         rain_sum = rain_sum + r
#       }
#     }
#     snow_ratio = snow_sum / (snow_sum + rain_sum)
#     return (snow_ratio)
#   }
# }


snow.fraction = function(watershed) {
  gridcode = watershed$gridcode
  return (snow.fraction.by.gc(gridcode))
}

# rain fraction
# input: Watershed object
rain.fraction = function(watershed) {
  return (1 - snow.fraction(watershed))
}




```





```{r, echo=TRUE}
# input: watersheds = list(ws1, ws2...) ws watershed object
# get.fraction = function(watersheds) {
#   snow_fraction = NULL
#   rain_fraction = NULL
#   gridcode = NULL
#   for (ws in watersheds) {
#     gridcode = c(gridcode, ws$gridcode)
#     snow_fraction = c(snow_fraction, snow_fraction(ws))
#     rain_fraction = c(rain_fraction, rain_fraction(ws))
#   }
#   return (data.frame(gridcode, snow_fraction, rain_fraction))
#   
# }


get.fraction = function(watersheds) {
  gridcodes = sapply(watersheds, FUN=function(x){x$gridcode})
  return (get.fraction.by.gc(gridcodes))
}


```


# Archive

<!-- ```{r, echo=TRUE} -->
<!-- get_fraction = function(shapes) { -->
<!--   grid_codes = shapes$gridcode -->
<!--   snow_ratios = NULL -->
<!--   rain_ratios = NULL -->
<!--   for (i in (1:length(grid_codes))) { -->
<!--     filename = paste0(grid_codes[i], "_dat.RData") -->
<!--     # exception handling -->
<!--     if (!(filename %in% fileNames)) { -->
<!--       snow_ratios = c(snow_ratios, NA) -->
<!--       rain_ratios = c(rain_ratios, NA) -->
<!--     } -->
<!--     else { -->
<!--       data = mget(load(paste0(path, grid_codes[i], "_dat.RData"))) -->
<!--       sr = snow_fraction(data) -->
<!--       rr = rain_fraction(data) -->
<!--       snow_ratios = c(snow_ratios, sr) -->
<!--       rain_ratios = c(rain_ratios, rr) -->
<!--     } -->
<!--   } -->
<!--   return (data.frame(grid_codes, snow_ratios, rain_ratios)) -->
<!-- } -->
<!-- ``` -->


<!-- #test -->
<!-- ```{r, echo=TRUE} -->
<!-- # indices = c(1061, 1273, 1368) -> watershed file:(1003, 1013, 1409) -->
<!-- get_fraction(shapes[c(1061,1273,1368)]) -->
<!-- render_piechart(shapes[c(1061,1273,1368)]) -->

<!-- ``` -->




```{r, echo=TRUE}
valid_gridcode = unlist(sapply(c(1:length(DATA)), FUN = function(i) {
  if (!is.null(DATA[[i]])) {i} else {NULL}
}))

```



```{r, echo=TRUE}
start_time = Sys.time()
valid_watersheds = load.watersheds(gridcodes = valid_gridcode)
end_time = Sys.time()
end_time - start_time
```


```{r, echo=TRUE}
start_time = Sys.time()
valid_fraction = get.fraction(valid_watersheds)
end_time = Sys.time()
end_time - start_time
```



```{r, echo=TRUE}
low_snow_gridcode = valid_fraction$gridcodes[valid_fraction$snow_fraction <= 0.03]

```







#========================================================================================
# Graphic
# load any info about the watersheds/shapes
```{r, echo = TRUE}
# input: list of Watershed object
# return: content => list of HTML string
show.fraction = function(watersheds) {
  content = NULL
  for (i in (1:length(watersheds))) {
    stats = get.fraction(watersheds)
    sr = stats[i,][2]
    rr = stats[i,][3]
    if (is.na(sr) || is.na(rr)) {
      content = c(content, paste0("<br>watershed:", stats[i,][1], 
                                  "<br>snow fraction:", stats[i,][2],
                                  "<br>rain fraction:", stats[i,][3]))
    } else {
      content = c(content, paste0("<br>watershed:", stats[i,][1], 
                                  "<br>snow fraction:", round(stats[i,][2],2)*100,"%",
                                  "<br>rain fraction:", round(stats[i,][3],2)*100,"%"))
    }
  }
  return (content)
}

# input: list of Watershed object
# return: content => list of HTML string
show.ts = function(watersheds) {
  content = NULL
  for (i in (1:length(watersheds))) {
    if (!is.null(watersheds[[i]])) {
      
    } else {
      content = c(content, "<br>no data")
    }
    
  }
  return (content)
}

# input: list of Watershed object
# return: content => list of HTML plot
show.plot = function(watersheds, option) {
  plot = NULL
  
  return (plot)
}

load.content = function(watersheds, option) {
  content = NULL
  switch(option,
         "fraction" = {content = show.fraction(watersheds)},
         "time series" = {content = show.ts(watersheds)},
         "piechart" = {content = show.plot(watersheds)}
         
  )
  return (content)
  
}

```


# TODO (under construction)
# plot watersheds's boundaries(shapes)
```{r, echo=TRUE}
# shapes: a set of shape objects, e.g., shp_dat[1:3];
# content: 
# map: boolean - TRUE puts boundaries on a map;
plot.shape = function(shapes, content=NULL, map=TRUE, option="fraction") {
  # center_longs = shapes$Longitude
  # center_lats = shapes$Latitude
  # list of x coord(longitude) of centroid
  center_longs = NULL
  # list of y coord(latitude) of centroid
  center_lats = NULL
  for (i in (1:length(shapes))) {
    center_longs = c(center_longs, mean(geom(shapes[i])[,3]))
    center_lats = c(center_lats, mean(geom(shapes[i])[,4]))
  }
  
  if (map) {
    # leaflet(sf::st_as_sf(shapes)) %>% addTiles() %>% addPolygons(fillOpacity=0.1) %>% addMarkers(lng=center_longs, lat=center_lats, popup=content) 
    # %>% addPopups(center_longs, center_lats, popup=content, options = popupOptions(closeButton = TRUE))
    m = leaflet(sf::st_as_sf(shapes))
    m = addTiles(m) 
    m = addPolygons(m, fillOpacity=0.1)
    m = addMarkers(m, lng=center_longs, lat=center_lats, popup=content)
    # # mouse hovering to get content
    # m = addMarkers(m, lng=center_longs, lat=center_lats, label=lapply(content, HTML))
    m
  }
  else {
    plot(shapes)
    # m = leaflet(sf::st_as_sf(shapes))
    # m = addPolygons(m, fillOpacity=0.1)
    # m = addMarkers(m, lng=center_longs, lat=center_lats, popup=content)
    # m
  }
}


# watersheds: list of watershed objects
plot.watersheds = function(watersheds, map = TRUE, option = "fraction") {
  content = load.content(watersheds, option)
  indices = sapply(watersheds, FUN=function(ws){ws$index})
  shapes = SHAPES[indices]
  plot.shape(shapes, content, map, option)
}

```

#tests
```{r, echo=TRUE}
# plot_shape(SHAPES[1:4], FALSE, "fraction")
# c1 = load_content(ws_1_2_1409,option = "fraction")
# plot_shape(SHAPES[1:4], map=TRUE, "fraction")
# plot_shape(SHAPES[c(1, 11, 101, 31, 77)], TRUE, "fraction")
# plot_shape(SHAPES[c(1061,1273,1368)], map=TRUE, "fraction")
# plot_shape(SHAPES[c(1061,1273,1368)], map=FALSE, "fraction")

plot.watersheds(watersheds=load.watersheds(c(1003,1013,1409)), map=TRUE)
plot.watersheds(watersheds=load.watersheds(c(1, 77, 101, 31)), map=TRUE)

```


























# inside region?
```{r, echo=TRUE}
# shape: a single shape file
# long_min, long_max, lat_min, lat_max: lower and upper bounds on longitude and latitude;
# Returns a boolean whether the shape is wholly inside the region or just partially inside;;
inside.region = function(shape, long_min, long_max, lat_min, lat_max) {
  x_min = xmin(shape)
  x_max = xmax(shape)
  y_min = ymin(shape)
  y_max = ymax(shape)
  return (long_min <= x_min && x_min <= long_max && lat_min <= y_min && y_max <= lat_max)
  # longs = geom(shape)[,3]
  # lats = geom(shape)[,4]
  # strict = TRUE
  # i = 1
  # while (strict && i <= length(longs)) {
  #   if (!(long_min <= longs[i] && longs[i] <= long_max && lat_min <= lats[i] && lats[i] <= lat_max)) {
  #     strict = FALSE
  #   }
  #   i = i + 1
  # }
  # return (strict)
}


```


#tests
```{r, echo=TRUE}
plot.shape(SHAPES[1], map=FALSE)
start_time = Sys.time()
inside.region(SHAPES[1], -132, -125, 57, 59.5)
inside.region(SHAPES[1], -133, -126, 57, 59.5)
end_time = Sys.time()
end_time - start_time

```





# in_which_region
```{r, echo=TRUE}
# shapes: a list of shape files
# Returns the index of the shape containing the longitude and latitude
in.which.region = function(shapes, long, lat) {
  indices = NULL
  for (i in (1:length(shapes))) {
    longs = geom(shapes[i])[,3]
    lats = geom(shapes[i])[,4]
    if (point.in.polygon(point.x = long, 
                         point.y = lat,
                         pol.x = longs,
                         pol.y = lats)) {
      indices = c(indices, i)
    }
  }
  return (indices)
}

```


#tests
```{r, echo=TRUE}
plot.shape(SHAPES[1:4], FALSE)
in.which.region(SHAPES[1:4], long = -125, lat = 55.1)
```


# in_which_region(return grid code/station ID)
```{r, echo=TRUE}
# in_which_region = function(shapes, long, lat) {
#   IDs = NULL
#   for (i in (1:length(shapes))) {
#     longs = geom(shapes[i])[,3]
#     lats = geom(shapes[i])[,4]
#     if (point.in.polygon(point.x = long, 
#                          point.y = lat,
#                          pol.x = longs,
#                          pol.y = lats)) {
#       IDs = c(IDs, shapes[i]$Station_ID)
#     }
#   }
#   return (IDs)
# }

```





```{r, echo=TRUE}
# shapes[1:2] is "SpatVector" object
# ext(shapes[1:2]) is "SpatExtent" object
# box is "SpatRaster" object
# Http error 404 can be solved by giving different online map provider
box = get_tiles(x = ext(SHAPES[1:3]), provider = "Esri.WorldStreetMap")
plotRGB(box)
lines(SHAPES[1:3], col = "blue")
lines(ext(SHAPES[1:3]))


```













